import axios from "axios";
import fs from "fs";
import FormData from "form-data";
import crypto from "crypto";
import { env } from "../config/env";
import { logger } from "./logger";

export type MalwareScanProvider = "none" | "virustotal" | "clamav";

interface ScanResult {
  clean: boolean;
  threats?: string[];
  provider: string;
  scanId?: string;
}

class MalwareService {
  private provider: MalwareScanProvider;
  private failMode: "fail_open" | "fail_closed";

  constructor() {
    this.provider = env.MALWARE_SCAN_PROVIDER;
    this.failMode = env.MALWARE_SCAN_FAIL_MODE;
  }

  private allowOnScanFailure(): boolean {
    return this.failMode === "fail_open";
  }

  /**
   * Scan a file for malware
   */
  async scanFile(filePath: string): Promise<ScanResult> {
    if (this.provider === "none") {
      return { clean: true, provider: "none" };
    }

    if (this.provider === "virustotal") {
      return this.scanWithVirusTotal(filePath);
    }

    if (this.provider === "clamav") {
      return this.scanWithClamAV(filePath);
    }

    throw new Error(`Unknown malware scan provider: ${this.provider}`);
  }

  /**
   * Scan with VirusTotal API
   * Requires VIRUSTOTAL_API_KEY environment variable
   */
  private async scanWithVirusTotal(filePath: string): Promise<ScanResult> {
    if (!env.VIRUSTOTAL_API_KEY) {
      logger.warn("VirusTotal API key not configured", {
        failMode: this.failMode,
      });

      if (this.allowOnScanFailure()) {
        return { clean: true, provider: "virustotal-skipped" };
      }

      return {
        clean: false,
        provider: "virustotal-misconfigured",
        threats: ["VirusTotal API key missing (fail-closed)"],
      };
    }

    try {
      const stats = fs.statSync(filePath);

      // VirusTotal has a 32MB file size limit for public API
      if (stats.size > 32 * 1024 * 1024) {
        logger.warn("File too large for VirusTotal scan", {
          size: stats.size,
          limit: 32 * 1024 * 1024,
        });

        if (this.allowOnScanFailure()) {
          return { clean: true, provider: "virustotal-size-limit" };
        }

        return {
          clean: false,
          provider: "virustotal-size-limit",
          threats: ["VirusTotal size limit exceeded (fail-closed)"],
        };
      }

      // Check if file hash already exists in VirusTotal database
      const fileHash = await this.calculateFileHash(filePath);
      const existingReport = await this.checkVirusTotalHash(fileHash);

      if (existingReport) {
        logger.info("File already scanned by VirusTotal", {
          hash: fileHash,
          clean: existingReport.clean,
        });
        return existingReport;
      }

      // Upload file for scanning
      const formData = new FormData();
      formData.append("file", fs.createReadStream(filePath));

      const uploadResponse = await axios.post(
        "https://www.virustotal.com/api/v3/files",
        formData,
        {
          headers: {
            ...formData.getHeaders(),
            "x-apikey": env.VIRUSTOTAL_API_KEY,
          },
          timeout: 30000,
        },
      );

      const analysisId = uploadResponse.data.data.id;

      logger.info("File submitted to VirusTotal", {
        analysisId,
        hash: fileHash,
      });

      // Wait for scan to complete (poll for results)
      const scanResult = await this.pollVirusTotalResults(analysisId);

      return scanResult;
    } catch (error: any) {
      logger.error("VirusTotal scan failed", error);

      if (this.allowOnScanFailure()) {
        // On error, allow upload but log warning
        return { clean: true, provider: "virustotal-error" };
      }

      return {
        clean: false,
        provider: "virustotal-error",
        threats: ["VirusTotal scan failed (fail-closed)"],
      };
    }
  }

  /**
   * Check if file hash exists in VirusTotal database
   */
  private async checkVirusTotalHash(hash: string): Promise<ScanResult | null> {
    try {
      const response = await axios.get(
        `https://www.virustotal.com/api/v3/files/${hash}`,
        {
          headers: {
            "x-apikey": env.VIRUSTOTAL_API_KEY,
          },
          timeout: 10000,
        },
      );

      const stats = response.data.data.attributes.last_analysis_stats;
      const malicious = stats.malicious || 0;
      const suspicious = stats.suspicious || 0;

      const clean = malicious === 0 && suspicious === 0;
      const threats: string[] = [];

      if (!clean) {
        const results = response.data.data.attributes.last_analysis_results;
        Object.entries(results).forEach(([engine, result]: [string, any]) => {
          if (
            result.category === "malicious" ||
            result.category === "suspicious"
          ) {
            threats.push(`${engine}: ${result.result}`);
          }
        });
      }

      return {
        clean,
        threats: clean ? undefined : threats,
        provider: "virustotal",
        scanId: hash,
      };
    } catch (error: any) {
      if (error.response?.status === 404) {
        // Hash not found in database
        return null;
      }
      throw error;
    }
  }

  /**
   * Poll VirusTotal for scan results
   */
  private async pollVirusTotalResults(
    analysisId: string,
    maxAttempts = 10,
  ): Promise<ScanResult> {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const response = await axios.get(
          `https://www.virustotal.com/api/v3/analyses/${analysisId}`,
          {
            headers: {
              "x-apikey": env.VIRUSTOTAL_API_KEY,
            },
            timeout: 10000,
          },
        );

        const status = response.data.data.attributes.status;

        if (status === "completed") {
          const stats = response.data.data.attributes.stats;
          const malicious = stats.malicious || 0;
          const suspicious = stats.suspicious || 0;

          const clean = malicious === 0 && suspicious === 0;
          const threats: string[] = [];

          if (!clean) {
            const results = response.data.data.attributes.results;
            Object.entries(results).forEach(
              ([engine, result]: [string, any]) => {
                if (
                  result.category === "malicious" ||
                  result.category === "suspicious"
                ) {
                  threats.push(`${engine}: ${result.result}`);
                }
              },
            );
          }

          return {
            clean,
            threats: clean ? undefined : threats,
            provider: "virustotal",
            scanId: analysisId,
          };
        }

        // Wait before next poll (exponential backoff)
        await new Promise((resolve) =>
          setTimeout(resolve, 1000 * (attempt + 1)),
        );
      } catch (error: any) {
        logger.error("Error polling VirusTotal results", error, {
          analysisId,
          attempt,
        });

        if (attempt === maxAttempts - 1) {
          throw error;
        }
      }
    }

    // If we reach here, scan timed out
    logger.warn("VirusTotal scan timed out", { analysisId });
    if (this.allowOnScanFailure()) {
      return { clean: true, provider: "virustotal-timeout" };
    }
    return {
      clean: false,
      provider: "virustotal-timeout",
      threats: ["VirusTotal scan timed out (fail-closed)"],
      scanId: analysisId,
    };
  }

  /**
   * Scan with ClamAV daemon (clamd)
   * Requires clamd running on CLAMAV_HOST:CLAMAV_PORT
   */
  private async scanWithClamAV(filePath: string): Promise<ScanResult> {
    if (!env.CLAMAV_HOST || !env.CLAMAV_PORT) {
      logger.warn("ClamAV not configured, skipping scan", {});
      if (this.allowOnScanFailure()) {
        return { clean: true, provider: "clamav-skipped" };
      }
      return {
        clean: false,
        provider: "clamav-misconfigured",
        threats: ["ClamAV not configured (fail-closed)"],
      };
    }

    try {
      const fileStream = fs.createReadStream(filePath);
      const chunks: Buffer[] = [];

      for await (const chunk of fileStream) {
        chunks.push(chunk as Buffer);
      }

      const fileBuffer = Buffer.concat(chunks);

      // Send to ClamAV via HTTP
      const response = await axios.post(
        `http://${env.CLAMAV_HOST}:${env.CLAMAV_PORT}/scan`,
        fileBuffer,
        {
          headers: {
            "Content-Type": "application/octet-stream",
          },
          timeout: 30000,
        },
      );

      const result = response.data;

      logger.info("ClamAV scan completed", { result });

      return {
        clean: result.indexOf("OK") !== -1,
        threats: result.indexOf("FOUND") !== -1 ? [result] : undefined,
        provider: "clamav",
      };
    } catch (error: any) {
      logger.error("ClamAV scan failed", error);

      if (this.allowOnScanFailure()) {
        // On error, allow upload but log warning
        return { clean: true, provider: "clamav-error" };
      }
      return {
        clean: false,
        provider: "clamav-error",
        threats: ["ClamAV scan failed (fail-closed)"],
      };
    }
  }

  /**
   * Calculate SHA256 hash of a file
   */
  private async calculateFileHash(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const hash = crypto.createHash("sha256");
      const stream = fs.createReadStream(filePath);

      stream.on("data", (data) => hash.update(data));
      stream.on("end", () => resolve(hash.digest("hex")));
      stream.on("error", reject);
    });
  }
}

export const malwareService = new MalwareService();
