import { afterEach, describe, expect, jest, test } from '@jest/globals';

type MalwareEnv = {
  MALWARE_SCAN_PROVIDER: 'none' | 'virustotal' | 'clamav';
  MALWARE_SCAN_FAIL_MODE: 'fail_open' | 'fail_closed';
  VIRUSTOTAL_API_KEY?: string;
  CLAMAV_HOST?: string;
  CLAMAV_PORT?: number;
};

const defaultEnv: MalwareEnv = {
  MALWARE_SCAN_PROVIDER: 'none',
  MALWARE_SCAN_FAIL_MODE: 'fail_open',
  VIRUSTOTAL_API_KEY: '',
  CLAMAV_HOST: '',
  CLAMAV_PORT: 8080,
};

async function importMalwareService(envOverrides: Partial<MalwareEnv> = {}) {
  jest.resetModules();

  const logger = {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  };

  const axiosMock = {
    get: jest.fn(async () => ({})) as any,
    post: jest.fn(async () => ({})) as any,
  };

  class FormDataMock {
    append = jest.fn();
    getHeaders = jest.fn(() => ({}));
  }

  // Default fs mock (override per-test as needed)
  const fsMock = {
    statSync: jest.fn(() => ({ size: 1024 })),
    createReadStream: jest.fn(() => ({ __stream: true })),
  };

  jest.doMock('../src/config/env', () => ({
    env: {
      ...defaultEnv,
      ...envOverrides,
    },
  }));

  jest.doMock('../src/utils/logger', () => ({ logger }));

  jest.doMock('axios', () => ({
    __esModule: true,
    default: axiosMock,
  }));

  jest.doMock('form-data', () => ({
    __esModule: true,
    default: FormDataMock,
  }));

  jest.doMock('fs', () => ({
    __esModule: true,
    default: fsMock,
  }));

  const mod = await import('../src/utils/malware.service');

  return {
    malwareService: mod.malwareService as any,
    mocks: {
      logger,
      axiosMock,
      fsMock,
      FormDataMock,
    },
  };
}

describe('MalwareService (fail-mode unit tests)', () => {
  afterEach(() => {
    jest.clearAllMocks();
    jest.useRealTimers();
  });

  test('none: scanFile() always returns clean', async () => {
    const { malwareService } = await importMalwareService({
      MALWARE_SCAN_PROVIDER: 'none',
      MALWARE_SCAN_FAIL_MODE: 'fail_closed',
    });

    const res = await malwareService.scanFile('C:/tmp/file.bin');
    expect(res).toEqual({ clean: true, provider: 'none' });
  });

  test('virustotal: missing API key => skipped (fail_open)', async () => {
    const { malwareService } = await importMalwareService({
      MALWARE_SCAN_PROVIDER: 'virustotal',
      MALWARE_SCAN_FAIL_MODE: 'fail_open',
      VIRUSTOTAL_API_KEY: '',
    });

    const res = await malwareService.scanFile('C:/tmp/file.bin');
    expect(res.clean).toBe(true);
    expect(res.provider).toBe('virustotal-skipped');
  });

  test('virustotal: missing API key => blocked (fail_closed)', async () => {
    const { malwareService } = await importMalwareService({
      MALWARE_SCAN_PROVIDER: 'virustotal',
      MALWARE_SCAN_FAIL_MODE: 'fail_closed',
      VIRUSTOTAL_API_KEY: '',
    });

    const res = await malwareService.scanFile('C:/tmp/file.bin');
    expect(res.clean).toBe(false);
    expect(res.provider).toBe('virustotal-misconfigured');
    expect(res.threats?.[0]).toContain('fail-closed');
  });

  test('virustotal: size limit => allow (fail_open) / block (fail_closed)', async () => {
    const bigSize = 33 * 1024 * 1024;

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'virustotal',
        MALWARE_SCAN_FAIL_MODE: 'fail_open',
        VIRUSTOTAL_API_KEY: 'key',
      });

      mocks.fsMock.statSync.mockReturnValueOnce({ size: bigSize });

      const res = await malwareService.scanFile('C:/tmp/big.bin');
      expect(res.clean).toBe(true);
      expect(res.provider).toBe('virustotal-size-limit');
    }

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'virustotal',
        MALWARE_SCAN_FAIL_MODE: 'fail_closed',
        VIRUSTOTAL_API_KEY: 'key',
      });

      mocks.fsMock.statSync.mockReturnValueOnce({ size: bigSize });

      const res = await malwareService.scanFile('C:/tmp/big.bin');
      expect(res.clean).toBe(false);
      expect(res.provider).toBe('virustotal-size-limit');
      expect(res.threats?.[0]).toContain('fail-closed');
    }
  });

  test('virustotal: upload error => allow (fail_open) / block (fail_closed)', async () => {
    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'virustotal',
        MALWARE_SCAN_FAIL_MODE: 'fail_open',
        VIRUSTOTAL_API_KEY: 'key',
      });

      malwareService.calculateFileHash = jest.fn(() => Promise.resolve('hash'));
      malwareService.checkVirusTotalHash = jest.fn(() => Promise.resolve(null));

      mocks.axiosMock.post.mockImplementationOnce(() => Promise.reject(new Error('boom')));

      const res = await malwareService.scanFile('C:/tmp/file.bin');
      expect(res.clean).toBe(true);
      expect(res.provider).toBe('virustotal-error');
    }

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'virustotal',
        MALWARE_SCAN_FAIL_MODE: 'fail_closed',
        VIRUSTOTAL_API_KEY: 'key',
      });

      malwareService.calculateFileHash = jest.fn(() => Promise.resolve('hash'));
      malwareService.checkVirusTotalHash = jest.fn(() => Promise.resolve(null));

      mocks.axiosMock.post.mockImplementationOnce(() => Promise.reject(new Error('boom')));

      const res = await malwareService.scanFile('C:/tmp/file.bin');
      expect(res.clean).toBe(false);
      expect(res.provider).toBe('virustotal-error');
      expect(res.threats?.[0]).toContain('fail-closed');
    }
  });

  test('virustotal: existing hash report short-circuits and does not upload', async () => {
    const { malwareService, mocks } = await importMalwareService({
      MALWARE_SCAN_PROVIDER: 'virustotal',
      MALWARE_SCAN_FAIL_MODE: 'fail_closed',
      VIRUSTOTAL_API_KEY: 'key',
    });

    const report = {
      clean: false,
      provider: 'virustotal',
      scanId: 'hash',
      threats: ['EngineX: BadThing'],
    };

    malwareService.calculateFileHash = jest.fn(() => Promise.resolve('hash'));
    malwareService.checkVirusTotalHash = jest.fn(() => Promise.resolve(report));

    const res = await malwareService.scanFile('C:/tmp/file.bin');

    expect(res).toEqual(report);
    expect(mocks.axiosMock.post).not.toHaveBeenCalled();
  });

  test('virustotal: poll timeout => allow (fail_open) / block (fail_closed)', async () => {
    jest.useFakeTimers();

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'virustotal',
        MALWARE_SCAN_FAIL_MODE: 'fail_open',
        VIRUSTOTAL_API_KEY: 'key',
      });

      mocks.axiosMock.get.mockImplementation(async () => ({
        data: { data: { attributes: { status: 'queued' } } },
      }));

      const p = malwareService.pollVirusTotalResults('analysis-id', 1);
      await jest.runAllTimersAsync();
      const res = await p;

      expect(res.clean).toBe(true);
      expect(res.provider).toBe('virustotal-timeout');
    }

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'virustotal',
        MALWARE_SCAN_FAIL_MODE: 'fail_closed',
        VIRUSTOTAL_API_KEY: 'key',
      });

      mocks.axiosMock.get.mockImplementation(async () => ({
        data: { data: { attributes: { status: 'queued' } } },
      }));

      const p = malwareService.pollVirusTotalResults('analysis-id', 1);
      await jest.runAllTimersAsync();
      const res = await p;

      expect(res.clean).toBe(false);
      expect(res.provider).toBe('virustotal-timeout');
      expect(res.threats?.[0]).toContain('fail-closed');
    }
  });

  test('clamav: missing host/port => skipped (fail_open) / blocked (fail_closed)', async () => {
    {
      const { malwareService } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'clamav',
        MALWARE_SCAN_FAIL_MODE: 'fail_open',
        CLAMAV_HOST: '',
        CLAMAV_PORT: undefined,
      });

      const res = await malwareService.scanFile('C:/tmp/file.bin');
      expect(res.clean).toBe(true);
      expect(res.provider).toBe('clamav-skipped');
    }

    {
      const { malwareService } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'clamav',
        MALWARE_SCAN_FAIL_MODE: 'fail_closed',
        CLAMAV_HOST: '',
        CLAMAV_PORT: undefined,
      });

      const res = await malwareService.scanFile('C:/tmp/file.bin');
      expect(res.clean).toBe(false);
      expect(res.provider).toBe('clamav-misconfigured');
      expect(res.threats?.[0]).toContain('fail-closed');
    }
  });

  test('clamav: request error => allow (fail_open) / block (fail_closed)', async () => {
    // Provide a simple async-iterable stream for "for await ... of".
    const stream = {
      async *[Symbol.asyncIterator]() {
        yield Buffer.from('a');
        yield Buffer.from('b');
      },
    };

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'clamav',
        MALWARE_SCAN_FAIL_MODE: 'fail_open',
        CLAMAV_HOST: 'localhost',
        CLAMAV_PORT: 3310,
      });

      mocks.fsMock.createReadStream.mockReturnValueOnce(stream as any);
      mocks.axiosMock.post.mockImplementationOnce(() => Promise.reject(new Error('down')));

      const res = await malwareService.scanFile('C:/tmp/file.bin');
      expect(res.clean).toBe(true);
      expect(res.provider).toBe('clamav-error');
    }

    {
      const { malwareService, mocks } = await importMalwareService({
        MALWARE_SCAN_PROVIDER: 'clamav',
        MALWARE_SCAN_FAIL_MODE: 'fail_closed',
        CLAMAV_HOST: 'localhost',
        CLAMAV_PORT: 3310,
      });

      mocks.fsMock.createReadStream.mockReturnValueOnce(stream as any);
      mocks.axiosMock.post.mockImplementationOnce(() => Promise.reject(new Error('down')));

      const res = await malwareService.scanFile('C:/tmp/file.bin');
      expect(res.clean).toBe(false);
      expect(res.provider).toBe('clamav-error');
      expect(res.threats?.[0]).toContain('fail-closed');
    }
  });

  test('clamav: OK result returns clean=true', async () => {
    const stream = {
      async *[Symbol.asyncIterator]() {
        yield Buffer.from('a');
      },
    };

    const { malwareService, mocks } = await importMalwareService({
      MALWARE_SCAN_PROVIDER: 'clamav',
      MALWARE_SCAN_FAIL_MODE: 'fail_closed',
      CLAMAV_HOST: 'localhost',
      CLAMAV_PORT: 3310,
    });

    mocks.fsMock.createReadStream.mockReturnValueOnce(stream as any);
    mocks.axiosMock.post.mockImplementationOnce(async () => ({ data: 'stream: OK' }));

    const res = await malwareService.scanFile('C:/tmp/file.bin');
    expect(res.clean).toBe(true);
    expect(res.provider).toBe('clamav');
    expect(res.threats).toBeUndefined();
  });

  test('clamav: FOUND result returns clean=false with threats', async () => {
    const stream = {
      async *[Symbol.asyncIterator]() {
        yield Buffer.from('a');
      },
    };

    const { malwareService, mocks } = await importMalwareService({
      MALWARE_SCAN_PROVIDER: 'clamav',
      MALWARE_SCAN_FAIL_MODE: 'fail_closed',
      CLAMAV_HOST: 'localhost',
      CLAMAV_PORT: 3310,
    });

    mocks.fsMock.createReadStream.mockReturnValueOnce(stream as any);
    mocks.axiosMock.post.mockImplementationOnce(async () => ({ data: 'stream: Eicar-Test-Signature FOUND' }));

    const res = await malwareService.scanFile('C:/tmp/file.bin');
    expect(res.clean).toBe(false);
    expect(res.provider).toBe('clamav');
    expect(res.threats).toEqual(['stream: Eicar-Test-Signature FOUND']);
  });
});
